<?php

/**
 * ProductCategory
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    enter
 * @subpackage model
 * @author     Связной Маркет
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class ProductCategory extends BaseProductCategory
{
  public function construct()
  {
    $this->mapValue('product_count', null);
  }

  public function preDelete($event)
  {
    $invoker = $event->getInvoker();

    $this->deleteResultCache($invoker);

    CacheEraser::getInstance()->log($this->getTable()->getCacheEraserKeys($invoker, 'delete'), 'product_category deleted');
  }

  public function preSave($event)
  {
    $invoker = $event->getInvoker();

    // If record has been modified adds keys to nginx file
    if ($invoker->isModified(true) && ($invoker->getTable() instanceof myDoctrineTable))
    {
      CacheEraser::getInstance()->log($invoker->getTable()->getCacheEraserKeys($invoker, 'save'), 'product_category changed');
    }

    $record = $event->getInvoker();
  }

  public function __toString()
  {
    return (string) $this->name;
  }

  public function toParams()
  {
    return array(
      'productCategory' => $this->token_prefix ? ($this->token_prefix.'/'.$this->token) : $this->token,
    );
  }

  public function getRootCategory(array $params = array())
  {
	  return $this->getTable()->getRootRecord($this, $params);
  }

  public function importFromCore(array $data)
  {
    parent::importFromCore($data);

    $link = trim(preg_replace('/^\/catalog/', '', $data['link']), '/');
    $v = explode('/', $link);
    $this->token = array_pop($v);
    $this->token_prefix = count($v) ? array_shift($v) : null;

    $this->photo = !empty($data['media_image']) ? $data['media_image'] : 'default.jpg';

    $this->product_view = 1 == $data['product_view_id'] ? 'compact' : 'expanded';

    //Импорт фильтров для категории
    $filterGroup = $this->getFilterGroup();
    if (empty($filterGroup))
    {
      $filterGroup = new ProductFilterGroup();
    }

    $filterGroup->importFromCore($data);

    $this->FilterGroup = $filterGroup;

    //Импорт тэгов для категории
    $tag_group_ids = array();
    foreach ($this->TagGroupRelation as $tagGroupRelation)
    {
      if (!empty($tagGroupRelation['core_id']))
      {
        $tag_group_ids['core_id-'.$tagGroupRelation['core_id']] = $tagGroupRelation['tag_group_id'];
      }
      else
      {
        $tag_group_ids[] = $tagGroupRelation['tag_group_id'];
      }
    }
    if (!empty($data['filter_tag_group']))
    {
      foreach ($data['filter_tag_group'] as $relationData)
      {
        unset($tag_group_ids['core_id-'.$relationData['id']]);
        $tagGroupProductCategoryRelation = TagGroupProductCategoryRelationTable::getInstance()->getByCoreId($relationData['id']);
        if (!$tagGroupProductCategoryRelation)
        {
          $tagGroupProductCategoryRelation = new TagGroupProductCategoryRelation();
        }

        $tagGroupProductCategoryRelation->importFromCore($relationData);
        $this->TagGroupRelation[] = $tagGroupProductCategoryRelation;
      }
    }

    //Удаляю все, что лишнее
    if ($this->id && count($tag_group_ids))
    {
      $q = Doctrine_Query::create()
        ->delete('TagGroupProductCategoryRelation ')
        ->where('product_category_id = ?', $this->id)
        ->andWhereIn('tag_group_id', array_values($tag_group_ids))
        ;

        $deleted = $q->execute();
    }

  }

  public function countProduct(array $params = array())
  {
    return ProductTable::getInstance()->countByCategory($this, $params);
  }

  public function getPreviewProduct()
  {
    return ProductTable::getInstance()->getByCategory($this);
  }

  public function getSubCategories()
  {
    return ProductCategoryTable::getInstance()->getSubList(array('root_id' => $this->root_id));
  }

  public function getChildList(array $params = array())
  {
    return ProductCategoryTable::getInstance()->getChildList($this, $params);
  }

  public function getLinkList(array $params = array())
  {
    return ProductCategoryLinkTable::getInstance()->getListByCategory($this, $params);
  }

  public function getUrlToken()
  {
    return $this->getTable()->getRecordUrlToken($this);
  }

/**
 * TODO: нуждается в рефакторинге
 *
 * @return TagGroup Collection
 */
  public function getTagGroupForFilter(array $params = array())
  {
    $table = $this->getTable();

    $key = $table->getQueryHash('productCategory-'.$this->id.'/tagGroup-forFilter', $params);

    $return = $table->getCachedByKey($key);
    if (!$return)
    {
      //делаем список тэгов без учета тегов без товаров

      //берем только тэги, у которых есть продукты
      $tagIds = ProductCategoryTable::getInstance()->getTagIds($this);

      if (!is_array($tagIds))
      {
        $tagIds = array($tagIds);
      }

      //возвращаем тэги, отсортированные в правильном порядке
      $return = $this->getTagGroupByIdWithOrder($tagIds, $params);
      if ($table->isCacheEnabled())
      {
        $table->getCache()->set($key, $return, 28800); // обновление кеша через 8 часов
      }
    }

    return $return;
  }
/**
 *
 * @return FilterGroup Collection
 */
  public function getFilterGroupForFilter()
  {
    //делаем список тэгов без учета тегов без товаров
    $categoryTable = ProductCategoryTable::getInstance();

    //берем property_id и option_id, которые существуют в этой категории
    $properties = ProductPropertyTable::getInstance()->getForFilter($this);

    //формируем новую коллекцию групп тегов только с рабочими тэгами
    $newFilter = ProductFilterTable::getInstance()->createList();

    $propertyIds = array();
    foreach ($properties as $key => $property)
    {
      $propertyIds[$property['id']] = $key;
    }

    $q = ProductFilterTable::getInstance()->createBaseQuery();
    $q->addWhere('productFilter.group_id = ?', $this->filter_group_id)
      ->orderBy('productFilter.position');

    $filters = $q->execute();

    foreach ($filters as $filter)
    {
      if (false
        || (('choice' == $filter->type) && isset($propertyIds[$filter->property_id]))
        || ('choice' != $filter->type)
      ) {
        if (isset($propertyIds[$filter->property_id]))
        {
          $filter['Property'] = $properties[$propertyIds[$filter->property_id]];
        }

        $newFilter[] = $filter;
      }
    }

    return $newFilter;
  }

  public function getDescendantIds(array $params = array())
  {
    return $this->getTable()->getDescendatIds($this, $params);
  }

  public function getAncestorIds(array $params = array())
  {
    return $this->getTable()->getAncestorIds($this, $params);
  }

  public function hasChildren()
  {
    return $this->getNode()->hasChildren();
  }

  public function isRoot()
  {
    return $this->getNode()->isRoot();
  }

  // TODO: удалить, роутинг для чего нужен?
  public function getUrl(){
      return '/catalog/' . $this->token;
  }

  // TODO: нуждается в рефакторинге
  public function getTagGroupByIdWithOrder(array $ids = array(), array $params = array())
  {
    if (!count($ids))
    {
      return array();
    }

    $q = TagGroupTable::getInstance()->createBaseQuery();
    $q->innerJoin('tagGroup.ProductCategoryRelation productCategoryRelation WITH productCategoryRelation.product_category_id = ?', $this->id)
      ->innerJoin('tagGroup.Tag tag')
      ->andWhereIn('tag.id', $ids)
      ->orderBy('productCategoryRelation.position, FIELD(tag.id, '.implode(',', $ids).')')
    ;

    TagGroupTable::getInstance()->setQueryParameters($q, $params);

    if (isset($params['hydrate_array']) && $params['hydrate_array'])
    {
      $q->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);
    }

    return  $q->execute();
  }

  public function getPhotoUrl($view = 0)
  {
    $urls = sfConfig::get('app_category_photo_url');

    return $this->getPhoto() ? $urls[$view].$this->getPhoto() : null;
  }

  public function getVariation()
  {
    $variation = mb_strtolower($this->name, 'utf-8');
    switch ($variation)
    {
      case 'мебель':
        $variation = 'мебели';
        break;
      case 'бытовая техника':
        $variation = 'бытовой технике';
        break;
      case 'товары для дома':
        $variation = 'товарах для дома';
        break;
      case 'товары для детей':
        $variation = 'товарах для детей';
        break;
      case 'сделай сам (инструменты)':
        $variation = 'сделай сам (инструменты)';
        break;
      case 'электроника':
        $variation = 'электронике';
        break;
      case 'украшения и часы':
        $variation = 'украшениях и часах';
        break;
      case 'спорт':
        $variation = 'спорте';
        break;
      case 'подарки':
        $variation = 'подарках';
        break;
    }

    return $variation;
  }

}
